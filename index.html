<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Roomscale VR Shooter - Fullscreen WebXR</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    width: 100%; height: 100%;
    background-color: black;
    font-family: monospace, monospace;
    color: white;
  }
  #overlay {
    position: absolute;
    top: 10px; left: 10px;
    background: rgba(0,0,0,0.5);
    padding: 8px 15px;
    border-radius: 6px;
    z-index: 10;
    user-select: none;
  }
  #enterVR {
    margin-top: 10px;
    font-size: 1.2em;
    cursor: pointer;
    padding: 10px 20px;
    background: #0066ff;
    border: none;
    border-radius: 6px;
    color: white;
  }
</style>
</head>
<body>
<div id="overlay">
  Score: <span id="score">0</span>
  <br />
  <button id="enterVR">Enter VR</button>
  <div id="msg" style="margin-top: 8px; font-size: 0.9em;"></div>
</div>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three';
import { XRControllerModelFactory } from 'https://cdn.skypack.dev/three/examples/jsm/webxr/XRControllerModelFactory.js';

let camera, scene, renderer;
let controller, controllerGrip;
let enemies = [];
let bullets = [];
let score = 0;

const scoreEl = document.getElementById('score');
const enterVRBtn = document.getElementById('enterVR');
const msgEl = document.getElementById('msg');

init();

function init() {
  scene = new THREE.Scene();

  // Environment skybox
  const loader = new THREE.CubeTextureLoader();
  const envMap = loader.load([
    'https://threejs.org/examples/textures/cube/skybox/px.jpg',
    'https://threejs.org/examples/textures/cube/skybox/nx.jpg',
    'https://threejs.org/examples/textures/cube/skybox/py.jpg',
    'https://threejs.org/examples/textures/cube/skybox/ny.jpg',
    'https://threejs.org/examples/textures/cube/skybox/pz.jpg',
    'https://threejs.org/examples/textures/cube/skybox/nz.jpg',
  ]);
  scene.background = envMap;

  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.6, 3);

  // Floor
  const floorGeo = new THREE.PlaneGeometry(30, 30);
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Lights
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
  hemiLight.position.set(0, 20, 0);
  scene.add(hemiLight);
  const dirLight = new THREE.DirectionalLight(0xffffff);
  dirLight.position.set(3, 10, 10);
  scene.add(dirLight);

  // Renderer setup
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  // Controllers
  controller = renderer.xr.getController(0);
  controller.addEventListener('select', shoot);
  scene.add(controller);

  const controllerModelFactory = new XRControllerModelFactory();
  controllerGrip = renderer.xr.getControllerGrip(0);
  controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
  scene.add(controllerGrip);

  // Spawn enemies randomly in roomscale area
  for (let i = 0; i < 15; i++) {
    const enemy = new THREE.Mesh(
      new THREE.BoxGeometry(0.5, 0.5, 0.5),
      new THREE.MeshStandardMaterial({ color: 0xff0000 })
    );
    enemy.position.set(
      (Math.random() - 0.5) * 20,
      0.25,
      (Math.random() - 0.5) * 20 - 5
    );
    scene.add(enemy);
    enemies.push(enemy);
  }

  window.addEventListener('resize', onWindowResize);

  enterVRBtn.addEventListener('click', startVR);

  checkXRSupport();
}

async function checkXRSupport() {
  if (navigator.xr) {
    try {
      const supported = await navigator.xr.isSessionSupported('immersive-vr');
      if (supported) {
        msgEl.textContent = 'Your device supports immersive VR! Click Enter VR to start.';
        enterVRBtn.disabled = false;
      } else {
        msgEl.textContent = 'Immersive VR NOT supported on this device.';
        enterVRBtn.disabled = true;
      }
    } catch (e) {
      msgEl.textContent = 'Error checking WebXR support: ' + e.message;
      enterVRBtn.disabled = true;
    }
  } else {
    msgEl.textContent = 'WebXR not available in this browser.';
    enterVRBtn.disabled = true;
  }
}

async function startVR() {
  try {
    const session = await navigator.xr.requestSession('immersive-vr', {
      optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking'],
    });
    renderer.xr.setSession(session);
    enterVRBtn.style.display = 'none';
    msgEl.textContent = '';
    animate();
    await fullscreen();
  } catch (e) {
    msgEl.textContent = 'Failed to start VR session: ' + e.message;
  }
}

function fullscreen() {
  if (document.fullscreenElement) return Promise.resolve();
  if (document.body.requestFullscreen) return document.body.requestFullscreen();
  return Promise.resolve();
}

function shoot() {
  const bullet = new THREE.Mesh(
    new THREE.SphereGeometry(0.03, 8, 8),
    new THREE.MeshBasicMaterial({ color: 0xffff00 })
  );
  bullet.position.setFromMatrixPosition(controller.matrixWorld);
  const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(controller.quaternion);
  bullet.userData.velocity = direction.multiplyScalar(0.6);
  scene.add(bullet);
  bullets.push(bullet);
}

function animate() {
  renderer.setAnimationLoop(() => {
    bullets.forEach((bullet, i) => {
      bullet.position.add(bullet.userData.velocity);

      enemies.forEach((enemy, j) => {
        if (enemy && bullet.position.distanceTo(enemy.position) < 0.5) {
          scene.remove(enemy);
          enemies[j] = null;
          scene.remove(bullet);
          bullets.splice(i, 1);
          score += 10;
          scoreEl.textContent = score;
        }
      });

      if (bullet.position.length() > 50) {
        scene.remove(bullet);
        bullets.splice(i, 1);
      }
    });

    renderer.render(scene, camera);
  });
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>
