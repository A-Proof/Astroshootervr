<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Immersive VR Shooter</title>
<style>
  body {
    margin: 0; overflow: hidden;
    background: #000;
    color: white;
    font-family: monospace;
  }
  #info {
    position: absolute;
    top: 10px; left: 10px;
    padding: 10px 15px;
    background: rgba(0,0,0,0.7);
    border-radius: 6px;
    z-index: 10;
    user-select: none;
  }
  #enterVR {
    display: block;
    margin-top: 15px;
    background: #06f;
    color: white;
    border: none;
    padding: 10px 15px;
    font-size: 1.1rem;
    cursor: pointer;
    border-radius: 6px;
  }
</style>
</head>
<body>
<div id="info">
  <div id="score">Score: 0</div>
  <button id="enterVR" style="display:none;">Start VR</button>
  <div id="message"></div>
</div>
<script type="module">

import * as THREE from 'https://cdn.skypack.dev/three';
import { XRControllerModelFactory } from 'https://cdn.skypack.dev/three/examples/jsm/webxr/XRControllerModelFactory.js';

let container, camera, scene, renderer;
let controller, controllerGrip;
let enemies = [], bullets = [];
let score = 0;
const scoreDisplay = document.getElementById('score');
const enterVRBtn = document.getElementById('enterVR');
const message = document.getElementById('message');

init();

function init() {
  container = document.body;

  // Setup renderer with XR enabled
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  container.appendChild(renderer.domElement);

  // Setup scene and camera
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);
  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.6, 3);

  // Lights
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
  hemiLight.position.set(0, 20, 0);
  scene.add(hemiLight);
  const dirLight = new THREE.DirectionalLight(0xffffff);
  dirLight.position.set(3, 10, 10);
  scene.add(dirLight);

  // Floor
  const floorGeo = new THREE.PlaneGeometry(30, 30);
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  scene.add(floor);

  // Controllers
  controller = renderer.xr.getController(0);
  controller.addEventListener('select', shoot);
  scene.add(controller);

  const controllerModelFactory = new XRControllerModelFactory();
  controllerGrip = renderer.xr.getControllerGrip(0);
  controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
  scene.add(controllerGrip);

  // Spawn enemies
  for (let i = 0; i < 10; i++) {
    const enemy = new THREE.Mesh(
      new THREE.BoxGeometry(0.5, 0.5, 0.5),
      new THREE.MeshStandardMaterial({ color: 0xff0000 })
    );
    enemy.position.set((Math.random() - 0.5) * 15, 0.25, (Math.random() - 0.5) * 15 - 5);
    scene.add(enemy);
    enemies.push(enemy);
  }

  window.addEventListener('resize', onWindowResize);

  checkXRSupport();
}

// Check WebXR support and manage VR session start button
async function checkXRSupport() {
  if (navigator.xr) {
    try {
      const isSupported = await navigator.xr.isSessionSupported('immersive-vr');
      if (isSupported) {
        enterVRBtn.style.display = 'inline-block';
        enterVRBtn.addEventListener('click', startVR);
      } else {
        message.innerText = 'WebXR immersive-vr not supported on this device.';
      }
    } catch (e) {
      message.innerText = 'Error checking WebXR support: ' + e.message;
    }
  } else {
    message.innerText = 'WebXR not available in this browser.';
  }
}

async function startVR() {
  try {
    const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking'] });
    renderer.xr.setSession(session);
    enterVRBtn.style.display = 'none';
    animate();
  } catch (e) {
    message.innerText = 'Failed to start VR session: ' + e.message;
  }
}

function shoot() {
  const bullet = new THREE.Mesh(
    new THREE.SphereGeometry(0.03, 8, 8),
    new THREE.MeshBasicMaterial({ color: 0xffff00 })
  );
  bullet.position.setFromMatrixPosition(controller.matrixWorld);

  const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(controller.quaternion);
  bullet.userData.velocity = direction.multiplyScalar(0.5);

  scene.add(bullet);
  bullets.push(bullet);
}

function animate() {
  renderer.setAnimationLoop(render);
}

function render() {
  bullets.forEach((bullet, i) => {
    bullet.position.add(bullet.userData.velocity);

    enemies.forEach((enemy, j) => {
      if (enemy && bullet.position.distanceTo(enemy.position) < 0.5) {
        scene.remove(enemy);
        enemies[j] = null;
        scene.remove(bullet);
        bullets.splice(i, 1);
        score += 10;
        scoreDisplay.textContent = 'Score: ' + score;
      }
    });

    if (bullet.position.length() > 50) {
      scene.remove(bullet);
      bullets.splice(i, 1);
    }
  });

  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>
